[toc]

# OS

## Linux

### 设备信息
```shell
lscpu       # cpu信息
man lscpu   # 指令解释: man 指令

df -h       # 查看硬盘使用情况
```

### 基本命令
```shell
pwd   # 当前路径
ls    # ll详细信息
cd .. # 回到上一级
'     # 进入quote，再按 ' 退出

mkdir folder   # 新建文件夹
sz filename    # 下载filename到本地

# 删除
rm filename   # 删除文件
rm -f folder  # 删除文件夹

# move
mv filename1 ../code/filename2
# filename1 是要转移的文件名
# filename2 转移后的文件名,可与filename1同名

ipython 	# 进入ipython
quit    	# 退出
```

### 压缩
```shell
zip -r new_name_filename need_zip_filename     # 压缩文件need_zip_filename
unzip filename
```

### screen
```shell
screen -S name 			# 新建一个叫name的session(会话)
screen -ls     			# 列出当前所有的session
screen -r name 			# 回到name这个session
screen -d name 			# 远程detach(分离）某个session
screen -d -r name_ 	    # 结束当前session并回到 name_ 这个session
screen -S name -X quit  # kill叫name的session
# 进入某个session后,先按键 ctrl+a, 再按 d 即可挂起(Detached)
```

### vim
```shell
vim filename.py		# 进入vim
i    			    # 进入插入模式

Esc		 	# 回到命令行模式
Esc :wq 	# 保存并退出
	:q! 	# 不保存并强制退出
	:q  	# 不保存文件,退出
```


### top
>VIRT：virtual memory usage 虚拟内存
>RES：resident memory usage 常驻内存
>SHR：shared memory 共享内存
q – 退出 top


### tips
```shell
cat bigname | split -b 2G - smallname. # smallname.aa / ab / ac
# 在windows本地对下载的2G文件重命名为1.zip.001，1.zip.002，1.zip.003 ……
# 打开cmd进入到存放文件目录中输入：
copy /b 1.zip.001+1.zip.002+1.zip.003 1.zip
# 当前目录生成1.zip，为最后的待解压文件
# 文件之间用加号+连接不能有空格, 另一种写法： copy /b 1.* 1.zip
```

## 计算机操作系统理论

### 概论

##### 基本特征

1. 并发
宏观上在一段时间内能同时运行多个程序
通过引入进程和线程，使得程序能够并发运行

2. 共享
系统中的资源可以被多个并发进程共同使用
有两种共享方式：互斥共享和同时共享。
互斥共享的资源称为临界资源，例如打印机，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问

3. 虚拟
虚拟技术把一个物理实体转换为多个逻辑实体
两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术
- 多个进程能在同一个处理器上并发执行，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换
- 虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中

4. 同步与异步
同步：下一步需要等待上一步的结果，上一步结束，下一步才能开始
异步：下一步无需等待上一步的结果，只需上一步有结果时接受即可

#### 基本功能

1. 进程管理
进程控制、进程同步、进程通信、死锁处理、处理机调度等

2. 内存管理
内存分配、地址映射、内存保护与共享、虚拟内存等

3. 文件管理
文件存储空间的管理、目录管理、文件读写管理和保护等

4. 设备管理
完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率
主要包括缓冲管理、设备分配、设备处理、虛拟设备等



### 进程管理
##### 进程与线程
- 进程
进程是资源分配的基本单位
进程控制块 (Process Control Block,  PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作

- 线程
一个进程中可以有多个线程，它们共享进程资源
线程间可以通过直接读写同一进程中的数据进行通信

##### 进程调度算法
进程状态切换：
- 就绪状态（ready）：等待被调度
- 运行状态（running）
- 阻塞状态（waiting）：等待资源
阻塞只能到就绪，阻塞不能直接转运行

进程调度算法：
**1.1 先来先服务 first-come first-serverd（FCFS）** 
按照请求的顺序进行调度

**1.2 短作业优先 shortest job first（SJF）** 
非抢占式的调度算法，按估计运行时间最短的顺序进行调度，长作业有可能会饿死

**1.3 最短剩余时间优先 shortest remaining time next（SRTN）** 
最短作业优先的抢占式版本（新来的进程会抢占CPU），按剩余运行时间的从小到大的顺序进行调度
当一个新的进程到达时，如果新的进程需要的时间更少，则挂起当前进程，运行新的进程

**2.1 时间片轮转** 
将所有就绪进程按 FCFS （先来先服务）的原则排成一个队列，每次每个队首进程可以执行一个时间片，执行完后队首放入队尾
时间片轮转算法的效率和时间片的大小有很大关系：
- 如果时间片太小，切换得太频繁会费时
- 而如果时间片过长，那么实时性就不能得到保证

**2.2 优先级调度** 
为每个进程分配一个优先级，按优先级进行调度
为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级

**2.3 多级反馈队列** 
一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次，耗时过大
多级队列是为这种耗时大的进程考虑，它设置了多个队列，每个队列对应的时间片大小都不同，例如 1, 2, 4, 8, ... 
进程在第一个队列没执行完，就会被移到下一级队列，下级队列的时间片大小大于上级队列

- 实时系统：
实时系统要求一个请求在一个确定时间内得到响应
分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时

##### 进程同步
1. 信号量

2. 临界区

3. 管程



##### 进程通信
1. 管道
2. 消息队列
3. 共享存储
4. 套接字
5. 信号量

### 内存管理
虚拟内存：为了把物理内存扩充成更大的逻辑内存


- 分页
虚拟内存采用的是分页技术，将地址空间划分成固定大小的页，每一页再与内存进行映射

页不需要映射到连续的物理内存

内存管理单元（MMU）管理着逻辑地址空间和物理内存的转换，其中的页表（Page table）存储着 页（程序地址空间） 和 页框（物理内存空间） 的映射表


- 页面置换算法
页面置换算法的主要目标是使页面置换频率最低
页的物理存储位置在内存与磁盘中交换的过程

1. 最佳
> OPT, Optimal replacement algorithm

是一种理论上的算法：
所选择的被换出的页面是最长时间不再被访问的，通常可以保证获得最低的缺页率


2. 最近最久未使用
> LRU, Least Recently Used
> 将最近最久未使用的页面换出

无法知道将来要使用的页面情况，但可以知道过去使用页面的情况
实现 LRU，需要在内存中维护一个所有页面的链表（限定长度）
当一个页面被访问时，将这个页面移到链表表头（如在链表中出现过，如果不在链表中直接添加为头结点），超出长度删除链表尾节点


3. 最近未使用
> NRU, Not Recently Used

每个页面都有两个状态位：R 与 M，页面被访问时设置页面的 R=1，当页面被修改时设置 M=1
R 位会定时被清零。可以将页面分成以下四类：
- R=0，M=0
- R=0，M=1
- R=1，M=0
- R=1，M=1

NRU 算法随机地换出
NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁访问的干净页面（R=1，M=0）。

4. 先进先出
> FIFO,  First In First Out

选择换出的是最先进入的页面

5. 第二次机会算法
FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：
当页面被访问 (读或写) 时设置该页面的 R 位为 1。
需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；
如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。


6. 时钟
> Clock

第二次机会算法需要在链表中移动页面，降低了效率
时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面




- 段页式


### 磁盘管理
